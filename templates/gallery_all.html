{% extends "base.html" %}

{% block styles %}
<style>
:root { --thumb-size: 180px; }

body.gallery-page{ overflow-y:auto; background:var(--bs-body-bg); }

.gallery-header{
  position:sticky; top:0; z-index:1030;
  backdrop-filter:blur(6px);
  background: color-mix(in oklab, var(--bs-body-bg) 85%, transparent);
  border-bottom:1px solid rgba(255,255,255,.08);
}

/* Grille principale (cards album) */
.g-grid{
  --g-thumb-size: 220px;
  display:grid;
  grid-template-columns: repeat(auto-fill, minmax(var(--g-thumb-size), 1fr));
  gap:1rem;
}

/* Carte d’album */
.album-card{ cursor:pointer; }
.meta-line{ min-height:28px; }

/* Patchwork dynamique : conteneur carré et images absolues centrées */
.patchwork{ position:relative; width:100%; padding-top:100%; border-radius:.75rem; overflow:hidden; background:#f5f5f5; }
.patchwork img{
  position:absolute; top:0; left:0;
  width:100%; height:100%;
  object-fit:cover; object-position:center;
  border:0;
}

/* Lightbox custom */
.lightbox{ position:fixed; inset:0; z-index:2000; display:none; background:rgba(0,0,0,.92); }
.lightbox.open{ display:grid; place-items:center; }
.lightbox img{ max-width:92vw; max-height:86vh; object-fit:contain; box-shadow:0 0 0 1px rgba(255,255,255,.08); border-radius:.5rem; }

.lb-toolbar{
  position:fixed; top:.5rem; left:.5rem; right:.5rem;
  display:flex; align-items:center; justify-content:space-between; gap:.5rem;
}
.lb-actions{ display:flex; gap:.5rem; }
.lb-index{ color:#fff; opacity:.8; font-size:.9rem; }

.lb-nav{ position:fixed; inset:0; display:flex; align-items:center; justify-content:space-between; pointer-events:none; }
.lb-nav .btn{ pointer-events:all; border-radius:999px; }

@media (max-width: 576px){
  :root { --thumb-size: 140px; }
  .lb-index{ display:none; }
}
</style>
{% endblock %}

{% block content %}
<main class="gallery-page">
  <div class="container py-3">
    <div id="grid" class="g-grid"></div>
    <div id="sentinel" class="py-4 text-center text-secondary">Chargement…</div>
  </div>

</main>

<!-- Lightbox -->
<div id="lightbox" class="lightbox" aria-hidden="true">
  <div class="lb-toolbar">
    <div class="lb-actions">
      <button id="lbClose" class="btn btn-light btn-sm" title="Fermer (Esc)"><i class="bi bi-x-lg"></i></button>
      <button id="lbDelete" class="btn btn-danger btn-sm" title="Supprimer" data-requires-write><i class="bi bi-trash3"></i></button>
      <span id="lbName" class="badge text-bg-dark"></span>
    </div>
    <div class="lb-index"><span id="lbIdx">1</span> / <span id="lbTotal">1</span></div>
  </div>
  <img id="lbImg" alt="">
  <div class="lb-nav px-2">
    <button id="lbPrev" class="btn btn-outline-light"><i class="bi bi-chevron-left"></i></button>
    <button id="lbNext" class="btn btn-outline-light"><i class="bi bi-chevron-right"></i></button>
  </div>
</div>
{% endblock %}

{% block scripts %}
{{ super() }}
<script>
// === ÉTAT & DOM ==============================================================
const grid = document.getElementById('grid');
const sentinel = document.getElementById('sentinel');
const state = { page:1, per:60, loading:false, done:false };

// Index d'albums (front) : key = "entity:id" → { entity,id,title,cardEl,photos:[{url,name,base}] }
const albums = new Map();

// Lightbox custom (ids fournis par ton HTML)
const LB = {
  root: document.getElementById('lightbox'),
  img:  document.getElementById('lbImg'),
  name: document.getElementById('lbName'),
  idx:  document.getElementById('lbIdx'),
  total:document.getElementById('lbTotal'),
  btnPrev: document.getElementById('lbPrev'),
  btnNext: document.getElementById('lbNext'),
  btnClose: document.getElementById('lbClose'),
  btnDelete: document.getElementById('lbDelete'),
  albumKey: null,
  index: 0,
};

function parseAlbumKeyFromUrl(url){
  try{
    const parts = new URL(url, window.location.origin).pathname.split('/');
    const entity = parts[3]; // prints | groups
    const id = parseInt(parts[4], 10);
    if(!entity || Number.isNaN(id)) return null;
    return { key:`${entity}:${id}`, entity, id };
  }catch{ return null; }
}

function albumTitle(entity, id, itemTitle){
  return itemTitle || (entity === 'prints' ? `Print #${id}` : `Group #${id}`);
}

function buildUrl(){
  const u = new URL('/api/gallery/photos', window.location.origin);
  u.searchParams.set('page', state.page);
  u.searchParams.set('per', state.per);
  return u;
}

// === LIGHTBOX ================================================================
function lbOpen(albumKey, startIndex=0){
  const a = albums.get(albumKey);
  if(!a || !a.photos.length) return;
  LB.albumKey = albumKey;
  LB.index    = Math.min(Math.max(0, startIndex), a.photos.length-1);
  lbRender();
  LB.root.classList.add('open');
}

function lbClose(){ LB.root.classList.remove('open'); }

function lbMove(delta){
  const a = albums.get(LB.albumKey);
  if(!a) return;
  LB.index = (LB.index + delta + a.photos.length) % a.photos.length;
  lbRender();
}

function lbRender(){
  const a = albums.get(LB.albumKey);
  const p = a.photos[LB.index];
  const specific = p.base || p.name || '';
  LB.name.textContent = specific ? `${a.title} - ${specific}` : a.title;
  LB.img.src = p.url;
  LB.img.alt = specific || a.title || '';
  LB.idx.textContent = String(LB.index + 1);
  LB.total.textContent = String(a.photos.length);
}

// Brancher les boutons + clavier
LB.btnPrev.addEventListener('click', ()=> lbMove(-1));
LB.btnNext.addEventListener('click', ()=> lbMove(+1));
LB.btnClose.addEventListener('click', lbClose);
LB.btnDelete.addEventListener('click', async ()=>{
  const a = albums.get(LB.albumKey);
  const p = a?.photos?.[LB.index];
  if(!p) return;
  if(!confirm('Supprimer cette photo ?')) return;
  // TODO: Appelle ton endpoint de suppression ici si besoin.
  a.photos.splice(LB.index, 1);
  if(!a.photos.length){
    // retire la carte
    a.cardEl.remove();
    albums.delete(LB.albumKey);
    lbClose();
    return;
  }
  updateAlbumUI(LB.albumKey);
  LB.index = Math.min(LB.index, a.photos.length - 1);
  lbRender();
});

document.addEventListener('keydown', (e)=>{
  if(!LB.root.classList.contains('open')) return;
  if(e.key === 'ArrowLeft') lbMove(-1);
  if(e.key === 'ArrowRight') lbMove(+1);
  if(e.key === 'Escape') lbClose();
});

// === RENDU ALBUMS ============================================================
function createAlbumCard(entity, id, title){
  const card = document.createElement('div');
  card.className = 'album-card';

  card.innerHTML = `
    <div class="patchwork"><!-- thumbs injectées --></div>
    <div class="mt-2 d-flex align-items-center gap-2 meta-line">
      <i class="bi bi-folder2 d-none album-icon"></i>
      <span class="text-truncate album-title" title="${title}">${title}</span>
      <span class="badge text-bg-secondary ms-auto d-none album-count">0</span>
    </div>
  `;

  // Clic = ouvrir le diaporama (index 0 par défaut)
  card.addEventListener('click', ()=>{
    const key = card.dataset.key;
    const a = albums.get(key);
    if(!a) return;
    lbOpen(key, 0);
  });

  grid.appendChild(card);
  return card;
}

function layoutRects(ratios) {
  const sum = ratios.reduce((a,b)=>a+b, 0) || 1;
  const rects = [];
  const W = 100, H = 100;

  if (ratios.length === 1) {
    rects.push({ left:0, top:0, width:W, height:H });
    return rects;
  }

  if (ratios.length === 2) {
    // Split vertical si ensemble "plutôt paysage", sinon horizontal
    const r1 = ratios[0], r2 = ratios[1];
    const totalR = r1 + r2;
    // aire proportionnelle -> largeur proportionnelle au ratio si vertical
    const preferVertical = (r1 >= 1 || r2 >= 1);
    if (preferVertical) {
      const w1 = (r1 / totalR) * W;
      const w2 = W - w1;
      rects.push({ left:0,   top:0, width:w1, height:H });
      rects.push({ left:w1,  top:0, width:w2, height:H });
    } else {
      // horizontal
      const h1 = (r1 / totalR) * H;
      const h2 = H - h1;
      rects.push({ left:0, top:0,  width:W, height:h1 });
      rects.push({ left:0, top:h1, width:W, height:h2 });
    }
    return rects;
  }

  if (ratios.length === 3) {
    // 2 en haut, 1 en bas pleine largeur, hauteurs proportionnelles aux "poids"
    const rTop1 = ratios[0], rTop2 = ratios[1], rBot = ratios[2];
    const topWeight = rTop1 + rTop2;
    const hTop = (topWeight / (topWeight + rBot)) * H;     // aire top proportionnelle
    const hBot = H - hTop;

    // Répartition horizontale en haut proportionnelle aux ratios
    const w1 = (rTop1 / (rTop1 + rTop2)) * W;
    const w2 = W - w1;

    rects.push({ left:0,  top:0,    width:w1, height:hTop });
    rects.push({ left:w1, top:0,    width:w2, height:hTop });
    rects.push({ left:0,  top:hTop, width:W,  height:hBot });
    return rects;
  }

  // ratios.length === 4
  // 2 en haut, 2 en bas ; hauteur de chaque rang proportionnelle à la somme des ratios de la rangée
  const r1 = ratios[0], r2 = ratios[1], r3 = ratios[2], r4 = ratios[3];
  const topWeight = r1 + r2, botWeight = r3 + r4;
  const hTop = (topWeight / (topWeight + botWeight)) * H;
  const hBot = H - hTop;

  const w1 = (r1 / (r1 + r2)) * W, w2 = W - w1;
  const w3 = (r3 / (r3 + r4)) * W, w4 = W - w3;

  rects.push({ left:0,  top:0,     width:w1, height:hTop });
  rects.push({ left:w1, top:0,     width:w2, height:hTop });
  rects.push({ left:0,  top:hTop,  width:w3, height:hBot });
  rects.push({ left:w3, top:hTop,  width:w4, height:hBot });
  return rects;
}

// Précharge dimensions des 1..4 premières photos et calcule un patchwork adapté
function renderPatchwork(card, photos) {
  const box = card.querySelector('.patchwork');
  // On prend les 4 premières photos (priorité aux premières)
  const pick = photos.slice(0, Math.min(photos.length, 4));

  if (!pick.length) { box.innerHTML = ''; return; }

  // Précharge dimensions pour ratios W/H
  Promise.all(pick.map(p => new Promise(resolve => {
    const img = new Image();
    img.onload = () => resolve({ url: p.url, w: img.naturalWidth || 1, h: img.naturalHeight || 1, name: p.name, base: p.base });
    img.onerror = () => resolve({ url: p.url, w: 1, h: 1, name: p.name, base: p.base });
    img.src = p.url;
  }))).then(items => {
    const ratios = items.map(it => (it.w / it.h) || 1);
    const rects = layoutRects(ratios);

    // Rendu absolu avec styles en pourcentage (évite tout conflit CSS)
    box.innerHTML = items.map((it, i) => {
      const r = rects[i];
      const style = `left:${r.left.toFixed(3)}%; top:${r.top.toFixed(3)}%; width:${r.width.toFixed(3)}%; height:${r.height.toFixed(3)}%;`;
      return `<img loading="lazy" src="${it.url}" style="${style}" alt="">`;
    }).join('');
  });
}
function updateAlbumUI(key){
  const a = albums.get(key);
  if(!a) return;
  const icon = a.cardEl.querySelector('.album-icon');
  const countEl = a.cardEl.querySelector('.album-count');

  renderPatchwork(a.cardEl, a.photos);

  if(a.photos.length > 1){
    icon.classList.remove('d-none');
    countEl.classList.remove('d-none');
    countEl.textContent = String(a.photos.length);
  }else{
    icon.classList.add('d-none');
    countEl.classList.add('d-none');
  }
}

function addPhotoToAlbum(item){
  const parsed = parseAlbumKeyFromUrl(item.url || item.path || item.src);
  if(!parsed) return;
  const { key, entity, id } = parsed;

  if(!albums.has(key)){
    const title = albumTitle(entity, id, item.item_title);
    const cardEl = createAlbumCard(entity, id, title);
    cardEl.dataset.key = key;
    albums.set(key, { entity, id, title, cardEl, photos: [] });
  }
  const a = albums.get(key);

  if(!a.photos.some(p => p.url === item.url)){
    a.photos.push({ url:item.url, name:item.name, base:item.base_name });
    updateAlbumUI(key);
  }
}

// === DATA LOADING ============================================================
async function loadNext(){
  if(state.loading || state.done) return;
  state.loading = true;
  sentinel.textContent = 'Chargement…';
  try{
    const res = await fetch(buildUrl());
    const data = await res.json();
    (data.items || []).forEach(addPhotoToAlbum);
    state.page++;
    state.done = !data.has_more;
    sentinel.textContent = state.done ? '— fin —' : 'Descendez pour charger la suite…';
  }catch(e){
    console.error(e);
    sentinel.textContent = 'Erreur de chargement';
  }finally{
    state.loading = false;
  }
}

const io = new IntersectionObserver((entries)=>{
  if(entries.some(e=>e.isIntersecting)) loadNext();
});
io.observe(sentinel);

// Boot
loadNext();
</script>
{% endblock %}